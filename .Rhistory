lt <- function(m) { m[lower.tri(m)] }
n_dyads <- choose(ergm.fit$network$gal$n, 2)
ergm.pred <- function()
{
flo.truth <- lt(as.matrix(ergm.fit$network))
sim.pred <- lt(as.matrix(simulate.ergm(ergm.fit)))
sum(flo.truth == sim.pred) / n_dyads
}
pct_correct_ergm <- replicate(replications, ergm.pred())
replications=100
pct_correct_ergm <- replicate(replications, ergm.pred())
stan.dta <- fergm.fit$stan.dta
stan.fit <- fergm.fit$stan.fit
truth <- stan.dta$y
predictions <- extract(stan.fit, "predictions")$predictions
pct_correct_fergm <- sapply(1:nrow(predictions),
function(r) sum(truth == predictions[r,]) / n_dyads)
correct_mat <- cbind(pct_correct_ergm, pct_correct_fergm)
improvement <- round(((mean(pct_correct_fergm)-mean(pct_correct_ergm))/mean(pct_correct_ergm))*100, 2)
cat(paste0("The FERGM fit reflects a ", improvement, "% improvement in tie prediction relative to the ERGM across ", replications, " simulations"))
return(correct_mat)
compare_predictions <- function(ergm.fit = NULL, fergm.fit = NULL, seed = NULL, replications = 500){
if(!is.null(seed)){
set.seed(seed)
} else {
warning("Note: This function relies upon network simulation to compare ERGM and FERGM predictions.  Consider specifying a seed to set to ensure replicability.")
}
lt <- function(m) { m[lower.tri(m)] }
n_dyads <- choose(ergm.fit$network$gal$n, 2)
ergm.pred <- function()
{
flo.truth <- lt(as.matrix(ergm.fit$network))
sim.pred <- lt(as.matrix(simulate.ergm(ergm.fit)))
sum(flo.truth == sim.pred) / n_dyads
}
pct_correct_ergm <- replicate(replications, ergm.pred())
stan.dta <- fergm.fit$stan.dta
stan.fit <- fergm.fit$stan.fit
truth <- stan.dta$y
predictions <- extract(stan.fit, "predictions")$predictions
pct_correct_fergm <- sapply(1:nrow(predictions),
function(r) sum(truth == predictions[r,]) / n_dyads)
correct_mat <- cbind(pct_correct_ergm, pct_correct_fergm)
improvement <- round(((mean(pct_correct_fergm)-mean(pct_correct_ergm))/mean(pct_correct_ergm))*100, 2)
cat(paste0("The FERGM fit reflects a ", improvement, "% improvement in tie prediction relative to the ERGM across ", replications, " simulations"))
return(correct_mat)
}
exists(ergm.fit)
?exists
exists(ergm.fit)
ergm.fit
predict_out <- compare_predictions(ergm.fit = ergm.fit, fergm.fit = fergm.fit, replications = 100)
stan.smry <- summary(fergm.fit$stan.fit)$summary
stan.smry <- summary(fergm.fit$stan.fit)$summary
beta_df <- stan.smry[grep("beta", rownames(stan.smry)),]
est <- round(beta_df[,c(1,4,8)], 3)
est # in order of "form"
est <- clean_summary(fergm.fit)
est <- clean_summary(fergm.fit,
custom_var_names = c("Edges", "Sex Homophily",
"GradeHomophily", "Race Homophily",
"GWESP", "Alternating K-Stars"))
est <- clean_summary(fergm.fit,
custom_var_names = c("Edges", "Sex Homophily",
"GradeHomophily", "Race Homophily",
"GWESP", "Alternating K-Stars"))
coef_plot(fergm.fit = fergm.fit)
coef_plot(fergm.fit = fergm.fit,
custom_var_names =  c("Edges", "Sex Homophily", "Grade Homophily",
"Race Homophily", "GWESP", "Alternating K-Stars"))
coef_plot(fergm.fit = fergm.fit)
coef_plot(fergm.fit = fergm.fit,
custom_var_names =  c("Edges", "Sex Homophily", "Grade Homophily",
"Race Homophily", "GWESP", "Alternating K-Stars"))
coef_plot(fergm.fit = fergm.fit,
ergm.fit = ergm.fit,
custom_var_names =  c("Edges", "Sex Homophily", "Grade Homophily",
"Race Homophily", "GWESP", "Alternating K-Stars"))
densities <- coef_posterior_density(fergm.fit = fergm.fit)
densities <- coef_posterior_density(fergm.fit = fergm.fit)
densities <- coef_posterior_density(fergm.fit = fergm.fit,
custom_var_names = c("Edges", "Sex Homophily",
"Grade Homophily", "Race Homophily",
"GWESP", "Alternating K-Stars"))
densities[[1]]
densities[[2]]
devtools::check()
predict_out <- compare_predictions(ergm_fit = ergm.fit, fergm_fit = fergm.fit, replications = 100)
devtools::build_vignettes()
devtools::build()
devtools::check()
devtools::build_win(version = "R-Release")
devtools::build_win(version = "R-release")
devtools::build_win(version = "R-dev")
?Deprecated
help("ergm-deprecated")
help("ergm-deprecated")
\
load("~/Dropbox/int group environment cases/FERGM replication/data and code/fergm/data/ergm.fit.rda")
ergm.fit$coef.init
library(statnet)
# Set seed for replication
set.seed(1)
# Load faux.mea.high daa
data("faux.mesa.high")
# Rename the object
mesa <- faux.mesa.high
statnet::update_statnet()
library(statnet)
# Set seed for replication
set.seed(1)
# Load faux.mea.high daa
data("faux.mesa.high")
# Rename the object
mesa <- faux.mesa.high
library(statnet)
# Set seed for replication
set.seed(1)
# Load faux.mea.high daa
data("faux.mesa.high")
# Rename the object
mesa <- faux.mesa.high
ergm.fit <- ergm(mesa ~ edges +
nodematch('Sex') +
nodematch('Grade', diff = FALSE) +
nodematch('Race', diff = FALSE) +
gwesp(decay = 0.2, fixed = TRUE) +
altkstar(lambda = 0.6, fixed = TRUE))
# FERGM fit
library(fergm)
form <- c("edges + nodematch('Sex') + nodematch('Grade', diff = FALSE) +
nodematch('Race', diff = FALSE) + gwesp(decay = 0.2, fixed = TRUE) +
altkstar(lambda = 0.6, fixed = TRUE)")
devtools::use_data(ergm.fit, internal = FALSE, overwrite=TRUE)
?fergm.fit
?fergm
fergm <- function(net = NULL, form = NULL, seed = 12345, chains = 4, warmup = 100, iter = 600, cores = 1){
# load necessary packages
extrafont::loadfonts()
to_indicator <- function(X, directed=FALSE)
{
if (isTRUE(directed)) {
stop("Directed networks not yet supported.")
} else {
X[,1] <- paste0("Sociality", X[,1])
X[,2] <- paste0("Sociality", X[,2])
factor.levels <- unique(unlist(X))
X[,1] <- factor(X[,1], levels=factor.levels)
X[,2] <- factor(X[,2], levels=factor.levels)
}
X
}
prepare_fergm_data <- function(net, form, verbose=FALSE)
{
## Temporary until directed code is added.
if (network::is.directed(net)) stop("Directed networks not yet supported.")
if (isTRUE(verbose)) cat("\n## Preparing FERGM dataset...")
nodes <- nrow(as.matrix(net))
ndyads <- network::network.dyadcount(net)
form <- stats::as.formula(paste("net ~", form))
if (isTRUE(verbose)) cat("\n##   building array...")
dta.array <- ergm::ergmMPLE(form, output="array", maxMPLEsamplesize=+Inf,
control=ergm::control.ergm(MPLE.max.dyad.types=ndyads*10))
if (isTRUE(verbose)) cat("\n##   building data.frame...")
ncoef <- length(dta.array$predictor[1,2,])
dta <- matrix(0, nrow=ndyads, ncol=3+ncoef)
idx <- 1
for (tail in 1:(nodes-1)) {
for (head in (tail+1):nodes) {
dta[idx,] <- c(dta.array$response[tail, head],
dta.array$predictor[tail, head, ],
tail,
head)
idx <- idx+1
}
}
dta <- data.frame(dta)
nm <- c("Y", names(dta.array$predictor[tail, head, ]),
"Sociality1", "Sociality2")
names(dta) <- nm
if (isTRUE(verbose)) cat("\n##   setting random effects indicators...\n")
if (network::is.directed(net)) {
stop("Directed networks not yet supported.")
} else {
Soc <- to_indicator(dta[,c("Sociality1", "Sociality2")])
dta[, "Sociality1"] <- Soc[,1]
dta[, "Sociality2"] <- Soc[,2]
}
dta
}
prepare_stan_data <- function(net, dta)
{
x <- dta[,2:(ncol(dta)-2)]
y <- dta[,1]
idx1 <- as.numeric(dta$Sociality1)
idx2 <- as.numeric(dta$Sociality2)
list(K = ncol(x),
N = ncol(net[,]),
D = nrow(x),
x = x,
y = y,
node1_idx = idx1,
node2_idx = idx2)
}
# Prepare data
if(!is.null(seed)){
set.seed(seed)
cat("Setting seed at the default value of 12345 for the seed argument.")
} else {
warning("Note: This function relies simulation.  Consider specifying a seed to set to ensure replicability.")
}
cat("Starting data preparation")
fergm.dta <- prepare_fergm_data(net, form)
stan.dta  <- prepare_stan_data(net, fergm.dta)
stan.dta$x <- as.matrix(stan.dta$x)      # deal with a recent change in rstan
# Allow for multiple cores to be specified
rstan_options(auto_write = TRUE)
options(mc.cores = cores)
# fit model using STAN
scode <- "data {
int<lower=1> K;		// number of predictors
int<lower=1> N;		// number of nodes
int<lower=0> D;		// number of potential ties
row_vector[K] x[D];		// predictors
int<lower=0,upper=1> y[D];	// ties (outcome)
int<lower=1> node1_idx[D];	// first node index
int<lower=1> node2_idx[D];	// second node index
}
parameters {
real<lower=0> sigma;		// sociality dispersion
vector[N] theta_raw;		// sociality effects
vector[K] beta;		// predictor coefficients
}
transformed parameters {
vector[N] theta;
theta = sigma * (theta_raw - mean(theta_raw));
}
model {
sigma ~ cauchy(0, 2);
theta_raw ~ normal(0, 1);
beta  ~ normal(0, 10);
{
vector[D] phi; // container for linear predictor
for (i in 1:D) {
// The 0.5 is to make the model consistent with weights multiple
// membership models place on the random effects. It has no effect on the
// fixed-effect results, just the scale of sigma and theta.
phi[i] = dot_product(beta, x[i]) +
0.5 * (theta[node1_idx[i]] + theta[node2_idx[i]]);
}
y ~ bernoulli_logit(phi);
}
}
generated quantities {
vector[D] predictions;
for (i in 1:D) {
predictions[i] = bernoulli_rng(inv_logit(dot_product(beta, x[i]) +
0.5 * (theta[node1_idx[i]] + theta[node2_idx[i]])));
}
}
"
stan.fit <- stan(model_code = scode,
data=stan.dta, chains=chains, seed=seed, warmup=warmup, iter=iter)
return(list(stan.fit = stan.fit, stan.dta = stan.dta, form = form))
}
devtools::built()
devtools::build()
install.packages("ergm")
install.packages("ergm")
install.packages("ergm")
devtools::build()
library(fergm)
library(statnet)
# Set seed for replication
set.seed(1)
# Load faux.mea.high daa
data("faux.mesa.high")
# Rename the object
mesa <- faux.mesa.high
ergm.fit <- ergm(mesa ~ edges +
nodematch('Sex') +
nodematch('Grade', diff = FALSE) +
nodematch('Race', diff = FALSE) +
gwesp(decay = 0.2, fixed = TRUE) +
altkstar(lambda = 0.6, fixed = TRUE))
ergm.fit <- ergm(mesa ~ edges +
nodematch('Sex') +
nodematch('Grade', diff = FALSE) +
nodematch('Race', diff = FALSE) +
gwesp(decay = 0.2, fixed = TRUE) +
altkstar(lambda = 0.6, fixed = TRUE))
set.seed(1)
ergm.fit <- ergm(mesa ~ edges +
nodematch('Sex') +
nodematch('Grade', diff = FALSE) +
nodematch('Race', diff = FALSE) +
gwesp(decay = 0.2, fixed = TRUE) +
altkstar(lambda = 0.6, fixed = TRUE))
devtools::use_data(ergm.fit, internal = FALSE, overwrite = TRUE)
fergm.fit <- fergm(net = mesa, form = form, chains = 1)
library(fergm)
form <- c("edges + nodematch('Sex') + nodematch('Grade', diff = FALSE) +
nodematch('Race', diff = FALSE) + gwesp(decay = 0.2, fixed = TRUE) +
altkstar(lambda = 0.6, fixed = TRUE)")
fergm.fit <- fergm(net = mesa, form = form, chains = 1)
devtools::document()
devtools::use_data(fergm.fit, internal = FALSE, overwrite = TRUE)
devtools::build()
devtools::check()
?importFrom
?deprecated
?network.dyadcount
?
ergmMPLE
?is.directed
?network
devtools::build()
devtools::check()
devtools::uild()
devtools::build()
devtools::check()
devtools::check()
devtools::build_win()
devtools::build_win(version = "R-release")
devtools::release()
devtools::release()
devtools::document()
devtools::check()
devtools::release()
devtools::release()
?simulate.ergm
compare_predictions <- function(ergm.fit = NULL, fergm.fit = NULL, seed = NULL, replications = 500){
if(!is.null(seed)){
set.seed(seed)
} else {
warning("Note: This function relies upon network simulation to compare ERGM and FERGM predictions.  Consider specifying a seed to set to ensure replicability.")
}
lt <- function(m) { m[lower.tri(m)] }
n_dyads <- choose(ergm.fit$network$gal$n, 2)
nw <- ergm.fit$network
new_formula <- update.formula(ergm.fit$formula, nw ~ .)
ergm_coefs <- ergm.fit$coefs
ergm.pred <- function()
{
flo.truth <- lt(as.matrix(nw))
sim.pred <- lt(as.matrix(simulate.ergm(new_formula, ergm_coefs)))
sum(flo.truth == sim.pred) / n_dyads
}
pct_correct_ergm <- replicate(replications, ergm.pred())
stan.dta <- fergm.fit$stan.dta
stan.fit <- fergm.fit$stan.fit
truth <- stan.dta$y
predictions <- extract(stan.fit, "predictions")$predictions
pct_correct_fergm <- sapply(1:nrow(predictions),
function(r) sum(truth == predictions[r,]) / n_dyads)
correct_mat <- cbind(pct_correct_ergm, pct_correct_fergm)
improvement <- round(((mean(pct_correct_fergm)-mean(pct_correct_ergm))/mean(pct_correct_ergm))*100, 2)
cat(paste0("The FERGM fit reflects a ", improvement, "% improvement in tie prediction relative to the ERGM across ", replications, " simulations"))
return(correct_mat)
}
load("~/Desktop/89.RData")
load("~/Desktop/fergm.89.RData")
compare_predictions <- function(ergm.fit = NULL, fergm.fit = NULL, seed = NULL, replications = 500){
if(!is.null(seed)){
set.seed(seed)
} else {
warning("Note: This function relies upon network simulation to compare ERGM and FERGM predictions.  Consider specifying a seed to set to ensure replicability.")
}
lt <- function(m) { m[lower.tri(m)] }
n_dyads <- choose(ergm.fit$network$gal$n, 2)
nw <- ergm.fit$network
new_formula <- update.formula(ergm.fit$formula, nw ~ .)
ergm_coefs <- ergm.fit$coefs
ergm.pred <- function()
{
flo.truth <- lt(as.matrix(nw))
sim.pred <- lt(as.matrix(simulate.ergm(new_formula, ergm_coefs)))
sum(flo.truth == sim.pred) / n_dyads
}
pct_correct_ergm <- replicate(replications, ergm.pred())
stan.dta <- fergm.fit$stan.dta
stan.fit <- fergm.fit$stan.fit
truth <- stan.dta$y
predictions <- extract(stan.fit, "predictions")$predictions
pct_correct_fergm <- sapply(1:nrow(predictions),
function(r) sum(truth == predictions[r,]) / n_dyads)
correct_mat <- cbind(pct_correct_ergm, pct_correct_fergm)
improvement <- round(((mean(pct_correct_fergm)-mean(pct_correct_ergm))/mean(pct_correct_ergm))*100, 2)
cat(paste0("The FERGM fit reflects a ", improvement, "% improvement in tie prediction relative to the ERGM across ", replications, " simulations"))
return(correct_mat)
}
preds <- compare_predictions(ergm.fit = ergm.89, fergm.fit = fergm.89, replications = 10)
library(ergm)
compare_predictions <- function(ergm.fit = NULL, fergm.fit = NULL, seed = NULL, replications = 500){
if(!is.null(seed)){
set.seed(seed)
} else {
warning("Note: This function relies upon network simulation to compare ERGM and FERGM predictions.  Consider specifying a seed to set to ensure replicability.")
}
lt <- function(m) { m[lower.tri(m)] }
n_dyads <- choose(ergm.fit$network$gal$n, 2)
nw <- ergm.fit$network
new_formula <- update.formula(ergm.fit$formula, nw ~ .)
ergm_coefs <- ergm.fit$coefs
ergm.pred <- function()
{
flo.truth <- lt(as.matrix(nw))
sim.pred <- lt(as.matrix(simulate.ergm(new_formula, ergm_coefs)))
sum(flo.truth == sim.pred) / n_dyads
}
pct_correct_ergm <- replicate(replications, ergm.pred())
stan.dta <- fergm.fit$stan.dta
stan.fit <- fergm.fit$stan.fit
truth <- stan.dta$y
predictions <- extract(stan.fit, "predictions")$predictions
pct_correct_fergm <- sapply(1:nrow(predictions),
function(r) sum(truth == predictions[r,]) / n_dyads)
correct_mat <- cbind(pct_correct_ergm, pct_correct_fergm)
improvement <- round(((mean(pct_correct_fergm)-mean(pct_correct_ergm))/mean(pct_correct_ergm))*100, 2)
cat(paste0("The FERGM fit reflects a ", improvement, "% improvement in tie prediction relative to the ERGM across ", replications, " simulations"))
return(correct_mat)
}
preds <- compare_predictions(ergm.fit = ergm.89, fergm.fit = fergm.89, replications = 10)
compare_predictions <- function(ergm.fit = NULL, fergm.fit = NULL, seed = NULL, replications = 500){
if(!is.null(seed)){
set.seed(seed)
} else {
warning("Note: This function relies upon network simulation to compare ERGM and FERGM predictions.  Consider specifying a seed to set to ensure replicability.")
}
lt <- function(m) { m[lower.tri(m)] }
n_dyads <- choose(ergm.fit$network$gal$n, 2)
nw <- ergm.fit$network
new_formula <- update.formula(ergm.fit$formula, nw ~ .)
ergm_coefs <- ergm.fit$coefs
ergm.pred <- function()
{
flo.truth <- lt(as.matrix(nw))
sim.pred <- lt(as.matrix(simulate.formula(new_formula, ergm_coefs)))
sum(flo.truth == sim.pred) / n_dyads
}
pct_correct_ergm <- replicate(replications, ergm.pred())
stan.dta <- fergm.fit$stan.dta
stan.fit <- fergm.fit$stan.fit
truth <- stan.dta$y
predictions <- extract(stan.fit, "predictions")$predictions
pct_correct_fergm <- sapply(1:nrow(predictions),
function(r) sum(truth == predictions[r,]) / n_dyads)
correct_mat <- cbind(pct_correct_ergm, pct_correct_fergm)
improvement <- round(((mean(pct_correct_fergm)-mean(pct_correct_ergm))/mean(pct_correct_ergm))*100, 2)
cat(paste0("The FERGM fit reflects a ", improvement, "% improvement in tie prediction relative to the ERGM across ", replications, " simulations"))
return(correct_mat)
}
preds <- compare_predictions(ergm.fit = ergm.89, fergm.fit = fergm.89, replications = 10)
ergm.fit=ergm.89
fergm.fit=fergm.89
if(!is.null(seed)){
set.seed(seed)
} else {
warning("Note: This function relies upon network simulation to compare ERGM and FERGM predictions.  Consider specifying a seed to set to ensure replicability.")
}
lt <- function(m) { m[lower.tri(m)] }
n_dyads <- choose(ergm.fit$network$gal$n, 2)
nw <- ergm.fit$network
new_formula <- update.formula(ergm.fit$formula, nw ~ .)
ergm_coefs <- ergm.fit$coefs
ergm_coefs <- ergm.fit$coef
ergm.pred <- function()
{
flo.truth <- lt(as.matrix(nw))
sim.pred <- lt(as.matrix(simulate.formula(new_formula, ergm_coefs)))
sum(flo.truth == sim.pred) / n_dyads
}
pct_correct_ergm <- replicate(replications, ergm.pred())
replications=10
pct_correct_ergm <- replicate(replications, ergm.pred())
sim.pred <- lt(as.matrix(simulate.formula.ergm(new_formula, ergm_coefs)))
?simulate.formula
new_formula
sim.pred <- lt(as.matrix(simulate.formula(object = new_formula, coef = ergm_coefs)))
load("~/Desktop/89.RData")
load("~/Desktop/fergm.89.RData")
library(fergm)
compare_predictions <- function(ergm.fit = NULL, fergm.fit = NULL, seed = NULL, replications = 500){
if(!is.null(seed)){
set.seed(seed)
} else {
warning("Note: This function relies upon network simulation to compare ERGM and FERGM predictions.  Consider specifying a seed to set to ensure replicability.")
}
lt <- function(m) { m[lower.tri(m)] }
n_dyads <- choose(ergm.fit$network$gal$n, 2)
nw <- ergm.fit$network
new_formula <- update.formula(ergm.fit$formula, nw ~ .)
ergm_coefs <- ergm.fit$coef
ergm.pred <- function()
{
flo.truth <- lt(as.matrix(nw))
sim.pred <- lt(as.matrix(simulate.formula(object = new_formula, coef = ergm_coefs)))
sum(flo.truth == sim.pred) / n_dyads
}
pct_correct_ergm <- replicate(replications, ergm.pred())
stan.dta <- fergm.fit$stan.dta
stan.fit <- fergm.fit$stan.fit
truth <- stan.dta$y
predictions <- extract(stan.fit, "predictions")$predictions
pct_correct_fergm <- sapply(1:nrow(predictions),
function(r) sum(truth == predictions[r,]) / n_dyads)
correct_mat <- cbind(pct_correct_ergm, pct_correct_fergm)
improvement <- round(((mean(pct_correct_fergm)-mean(pct_correct_ergm))/mean(pct_correct_ergm))*100, 2)
cat(paste0("The FERGM fit reflects a ", improvement, "% improvement in tie prediction relative to the ERGM across ", replications, " simulations"))
return(correct_mat)
}
preds <- compare_predictions(ergm.fit = ergm.89, fergm.fit = fergm.89, replications = 10)
